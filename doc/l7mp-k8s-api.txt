#+LaTeX_HEADER:\usepackage[margin=2cm]{geometry}
#+LaTeX_HEADER:\usepackage{enumitem}
#+LaTeX_HEADER:\renewcommand{\ttdefault}{pcr}
#+LaTeX_HEADER:\lstdefinelanguage{yaml}{basicstyle=\ttfamily\scriptsize,frame=lrtb,framerule=1pt,framexleftmargin=1pt,showstringspaces=false}
#+LaTeX_HEADER:\usepackage{etoolbox}
#+LaTeX_HEADER:\makeatletter\patchcmd{\@verbatim}{\verbatim@font}{\verbatim@font\scriptsize}{}{}\makeatother
#+LATEX:\setitemize{noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt}
#+OPTIONS: toc:nil author:nil ^:nil

#+TITLE: L7mp Kubernetes API: A Simple UDP API Gateway

* General considerations

- The API specifies two CRDs: a VirtualService (name may change later)
  and a Route CRD. VirtualService objects wrap listener side sockets,
  while Route objects specify the .
- If a VirtualService contains an in-line ruleset then it will forward
  the received traffic based on the route specified for the matching
  rule. Otherwise, it is a stub VirtualService that works in a
  request-response mode.
- The =destination=, =ingress= and =egress= specifications in the
  VirtualService route must be either a proper VirtulService name, in
  which case the client-side connection parameters (cluster spec) are
  taken from the VirtulService specification, or a Kubernetes service,
  in which case the client-side specification is taken from the
  =port=, =protocol=, and =targetPort= fields in the service
  spec. (Optionally, the Kubernetes operator may automatically define
  a default VirtulService object for each user-defined Kubernetes
  service, dunno which option is better.)
- Each VirtualService should have a short name (=name=) and a
  fully-specified name (like
  =name.namespace.virtualservice.cluster.local=). If a VirtualService
  refers to another VirtualService with a short name then that
  VirtualService is assumed to be in the same namespace. To refer to a
  VirtualService in another namespace, use the fully specified name
- The default l7mp API port is TCP:1234. The operator should warn on
  clashing port definitions.

* Example

Functionality:
- set up a gateway as a UDP listener that accepts connections from a
  specified source IP/UDP port
- set metadata
- call out to a transcoder middlepoint that accepts connections on a
  Unix domain socket (UDS), but expose this server (which would
  otherwise serve local connections only) via a WebSocket listener for
  remote callers
- then route to a worker service which is a default Kubernetes service
- there are no middlepoints (transformers) in the downlink direction
  (we could easily add one)

:                 +------------+
:                 | transcoder |
:                 |UDS:/var/...|
:                 +------------+
:                 |l7mp sidecar|
:                 |  WS: 8888  |
:                 +------------+
:                       A |
:      +--------+ id:1  | |      +---------+
:  --> |gateway |-------+ +----->|worker   |
:  <-- |UDP:9001|<---------------|UDP:9999 |
:      +--------+                +---------+

* Environment

A set of deployments/services must to be configured manually
beforehand in the =default= namespace:
- a =gateway= deployment/service identified by the label
  =app:gateway=: a set of =l7mp= pods with =hostNetwork:true= setting
- a =transcoder= deployment identified by the label =app:transcoder=
  and with each pod containing two containers: a container for the
  transcoder process itself that accepts connections via UDS (can be a
  UDS echo server for testing) and another l7mp container that
  implements the sidecar
- a =worker= deployment/service identified by the label =app:worker=:
  some worker service that processes the UDP payloads (can be a
  HTTP/WS echo server for testing),


* Config

#+BEGIN_SRC yaml
apiVersion: l7mp.io/v1
kind: VirtualService
metadata:
  name: transcoder
  namespace: default
spec:
  selector:
    matchLabels:
      app: transcoder
  listener:
    spec: { protocol: WebSocket, port: 9999 }
    rules:
      action:
        route:
          destination:
            spec:
              protocol: UnixDomainSocket
              filename: "/var/run/sock/uds-echo.sock"

---

apiVersion: l7mp.io/v1
kind: VirtualService
metadata:
  name: worker
  namespace: default
spec:
  selector:
    matchLabels:
      app: worker

---

apiVersion: l7mp.io/v1
kind: VirtualService
metadata:
  name: my-udp-service
  namespace: default
  selector:
    serviceName: gateway
    namespace: default
spec:
  virtualHost:
  - name: my-udp-endpoint
    spec: { protocol: UDP, port: 9001 }
    rules:
    - match:
        op: and
        apply:
          - { op: starts, path: '/IP/src_addr', value: '10.0.0' }
          - { op: test, path: '/UDP/src_port', value: 9001 }
      action:
        rewrite:
          - path: "HTTP/headers"
            value: { id: 1 }
        route:
          cluster: worker
          ingress:
            - transcoder
      options:
        removeOrphanSessions: true
#+END_SRC

* Sessions

Eventually, we should be able to query/kill live streams/sessions from the
data plane, but currently this is a TODO

* How K8s API objects map to L7mp objects

|----------------+---------------+------|
| K8s API        | L7mp REST API | Note |
|----------------+---------------+------|
| Upstream       | Cluster       | v1   |
| VirtualService | Listener      | v1   |
| Session        | Session       | ???  |
| Gateway        | Listener      | TODO |
| Route          | Route         | TODO |
|----------------+---------------+------|
